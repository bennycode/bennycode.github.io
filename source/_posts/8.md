---
title: TypeScript code coverage with Karma
date: 2019/4/29 16:53:35
categories:
  - [TypeScript, Setup]
tags:
  - karma
  - webpack
  - babel
  - typescript
  - istanbul
  - coverage
  - preprocessor
---

## Baseline

- Node.js v10.9.0
- yarn v1.15.2

{% codeblock lang:json package.json %}
{
  "devDependencies": {
    "jasmine": "3.4.0"
  },
  "main": "src/main.js",
  "name": "karma-webpack-babel-typescript-istanbul",
  "scripts": {
    "start": "node index.js",
    "test": "jasmine --config=jasmine.json"
  },
  "version": "0.0.0"
}
{% endcodeblock %}

{% codeblock lang:json jasmine.json %}
{
  "random": true,
  "spec_dir": "src",
  "spec_files": [
    "**/*test.js"
  ],
  "stopSpecOnExpectationFailure": true
}
{% endcodeblock %}

{% codeblock lang:js index.js %}
const afterTwoSeconds = require('./src/main');

afterTwoSeconds(() => {
  console.log('I will be called after 2 seconds.');
});
{% endcodeblock %}

{% codeblock lang:js src/main.js %}
module.exports = function afterTwoSeconds(callback) {
  return new Promise((resolve) => {
    setTimeout(() => {
      callback();
      resolve();
    }, 2000);
  });
};
{% endcodeblock %}

{% codeblock lang:js src/main.test.js %}
const afterTwoSeconds = require('./main');

describe('afterTwoSeconds', () => {
  it('resolves after 2 seconds', async () => {
    const myCallbackSpy = jasmine.createSpy('myCallbackSpy');
    await afterTwoSeconds(myCallbackSpy);
    expect(myCallbackSpy).toHaveBeenCalled();
  });
});
{% endcodeblock %}

## Add Karma

### Update dependencies

Karma needs an [adapter](https://npmjs.org/browse/keyword/karma-adapter) to know about the Jasmine testing framework. It also needs a [browser launcher](https://npmjs.org/browse/keyword/karma-launcher) to run the tests within a browser environment.

{% codeblock lang:json mark:4-6,12 package.json %}
{
  "devDependencies": {
    "jasmine": "3.4.0",
    "karma": "4.1.0",
    "karma-chrome-launcher": "2.2.0",
    "karma-jasmine": "2.0.1"
  },
  "main": "src/main.js",
  "name": "karma-webpack-babel-typescript-istanbul",
  "scripts": {
    "start": "node index.js",
    "test": "karma start"
  },
  "version": "0.0.0"
}
{% endcodeblock %}

### Update export

Karma will run the tests inside the operating system's Chrome browser which was in my case Chrome v74. The browser environment does not know about `module.exports`, so we will use the `window` namespace to export our `afterTwoSeconds` function:

{% codeblock lang:js mark:10-14 src/main.js %}
function afterTwoSeconds(callback) {
  return new Promise((resolve) => {
    setTimeout(() => {
      callback();
      resolve();
    }, 2000);
  });
}

if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
  module.exports = afterTwoSeconds;
} else {
  window.afterTwoSeconds = afterTwoSeconds;
}
{% endcodeblock %}

Note: We still export our code for Node.js environments, to make our code work in both worlds. That's why we keep [setTimeout](https://nodejs.org/dist/latest-v10.x/docs/api/timers.html#timers_settimeout_callback_delay_args) because it is available in Node.js and browser environments. If we would write `window.setTimeout` it would only work in browsers but fail in Node.js. 

### Update test

Our tests will run in the browser so we cannot import code with a `require` statement (CommonJS syntax) anymore and need to use the `window` namespace:

{% codeblock lang:js mark:4 src/main.test.js %}
describe('afterTwoSeconds', () => {
  it('resolves after 2 seconds', async () => {
    const myCallbackSpy = jasmine.createSpy('myCallbackSpy');
    await window.afterTwoSeconds(myCallbackSpy);
    expect(myCallbackSpy).toHaveBeenCalled();
  });
});
{% endcodeblock %}

### Add Karma configuration

A Karma configuration can be interactively created by running `npx karma init`. In our case we reuse the file paths from our Jasmine configuration.

For a successful Karma test run it is important to declare the source code and test code within the `files` property.

Karma can be equipped with a custom [test reporter](https://npmjs.org/browse/keyword/karma-reporter) but for now we are good with the standard `progress` reporter:

{% codeblock lang:js karma.conf.js %}
const jasmineConfig = require('./jasmine.json');

module.exports = function (config) {
  config.set({
    autoWatch: false,
    basePath: jasmineConfig.spec_dir,
    browsers: ['Chrome'],
    colors: true,
    concurrency: Infinity,
    exclude: [],
    files: [
      'main.js',
      ...jasmineConfig.spec_files
    ],
    frameworks: ['jasmine'],
    logLevel: config.LOG_INFO,
    port: 9876,
    preprocessors: {},
    reporters: ['progress'],
    singleRun: true,
  });
};
{% endcodeblock %}

## Add Webpack

### Update dependencies

We need to add `webpack-karma` so that Karma can use `webpack` to preprocess files. This also requires us to include `webpack` in our list of dependencies as it is a peer dependency of `webpack-karma`:

{% codeblock lang:json mark:7-8 package.json %}
{
  "devDependencies": {
    "jasmine": "3.4.0",
    "karma": "4.1.0",
    "karma-chrome-launcher": "2.2.0",
    "karma-jasmine": "2.0.1",
    "karma-webpack": "3.0.5",
    "webpack": "4.30.0"
  },
  "main": "src/main.js",
  "name": "karma-webpack-babel-typescript-istanbul",
  "scripts": {
    "start": "node index.js",
    "test": "karma start"
  },
  "version": "0.0.0"
}
{% endcodeblock %}

**Common mistake**

> ERROR [preprocess]: Can not load "webpack", it is not registered!
> Perhaps you are missing some plugin?

This happens when you run `karma start` and you forgot to install `webpack`.

### Add Webpack configuration

Thanks to webpack's zero configuration mode and its default settings, we don't need to specify much. All we do is defining a "development" mode to get detailed messages in case of preprocessing errors:  

{% codeblock lang:js webpack.config.js %}
module.exports = {
  mode: 'development'
};
{% endcodeblock %}

Using a "development" mode will decrypt error messages like `TypeError: r is not a function`.

### Update Karma configuration

In the previous Karma setup, our test code was relying that our business logic is exposed to the `window` namespace (`window.afterTwoSeconds`). Having webpack in place we will now load our business logic through our test code. That's why we don't need to declare our business logic anymore within Karma's `files` pattern. It's sufficient if we just point Karma to our test code because the tests will import the main source code for us. We can also reuse our webpack configuration by requiring it. To activate webpack, we need to declare it as a preprocessor for our test code. We also need to add the webpack configuration to our Karma configuration:

{% codeblock lang:js mark:1-2,7,12-14,18-20,23 karma.conf.js %}
const testCode = 'src/**/*test.js';
const webpackConfig = require('./webpack.config.js');

module.exports = function (config) {
  config.set({
    autoWatch: false,
    basePath: '',
    browsers: ['Chrome'],
    colors: true,
    concurrency: Infinity,
    exclude: [],
    files: [
      {pattern: testCode, watched: false}
    ],
    frameworks: ['jasmine'],
    logLevel: config.LOG_INFO,
    port: 9876,
    preprocessors: {
      [testCode]: ['webpack']
    },
    reporters: ['progress'],
    singleRun: true,
    webpack: webpackConfig
  });
};
{% endcodeblock %}

### Update imports

Our test code will now be preprocessed by webpack which means that we can use Node.js features like `require` statements to import code. Webpack will make sure that the `require` statements get processed into something that can be understood by our Browser environment:

{% codeblock lang:js mark:1,6 karma.conf.js %}
const afterTwoSeconds = require('./main');

describe('afterTwoSeconds', () => {
  it('resolves after 2 seconds', async () => {
    const myCallbackSpy = jasmine.createSpy('myCallbackSpy');
    await afterTwoSeconds(myCallbackSpy);
    expect(myCallbackSpy).toHaveBeenCalled();
  });
});
{% endcodeblock %}

## Add Babel

...