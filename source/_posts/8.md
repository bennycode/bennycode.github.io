---
title: TypeScript code coverage with Karma
date: 2019/4/29 16:53:35
categories:
  - [TypeScript, Setup]
tags:
  - karma
  - webpack
  - babel
  - typescript
  - istanbul
  - coverage
  - preprocessor
---

## Baseline

- Node.js v10.9.0
- yarn v1.15.2

{% codeblock lang:json package.json %}
{
  "devDependencies": {
    "jasmine": "3.4.0"
  },
  "main": "src/main.js",
  "name": "karma-webpack-babel-typescript-istanbul",
  "scripts": {
    "start": "node index.js",
    "test": "jasmine --config=jasmine.json"
  },
  "version": "0.0.0"
}
{% endcodeblock %}

{% codeblock lang:json jasmine.json %}
{
  "random": true,
  "spec_dir": "src",
  "spec_files": [
    "**/*test.js"
  ],
  "stopSpecOnExpectationFailure": true
}
{% endcodeblock %}

{% codeblock lang:js index.js %}
const afterTwoSeconds = require('./src/main');

afterTwoSeconds(() => {
  console.log('I will be called after 2 seconds.');
});
{% endcodeblock %}

{% codeblock lang:js src/main.js %}
module.exports = function afterTwoSeconds(callback) {
  return new Promise((resolve) => {
    setTimeout(() => {
      callback();
      resolve();
    }, 2000);
  });
};
{% endcodeblock %}

{% codeblock lang:js src/main.test.js %}
const afterTwoSeconds = require('./main');

describe('afterTwoSeconds', () => {
  it('resolves after 2 seconds', async () => {
    const myCallbackSpy = jasmine.createSpy('myCallbackSpy');
    await afterTwoSeconds(myCallbackSpy);
    expect(myCallbackSpy).toHaveBeenCalled();
  });
});
{% endcodeblock %}

## Add Karma

### Update dependencies

Karma needs an [adapter](https://npmjs.org/browse/keyword/karma-adapter) to know about the Jasmine testing framework. It also needs a [browser launcher](https://npmjs.org/browse/keyword/karma-launcher) to run the tests within a browser environment.

{% codeblock lang:json mark:4-6,12 package.json %}
{
  "devDependencies": {
    "jasmine": "3.4.0",
    "karma": "4.1.0",
    "karma-chrome-launcher": "2.2.0",
    "karma-jasmine": "2.0.1"
  },
  "main": "src/main.js",
  "name": "karma-webpack-babel-typescript-istanbul",
  "scripts": {
    "start": "node index.js",
    "test": "karma start"
  },
  "version": "0.0.0"
}
{% endcodeblock %}

### Update export

Karma will run the tests inside the operating system's Chrome browser which was in my case Chrome v74. The browser environment does not know about `module.exports`, so we will use the `window` namespace to export our `afterTwoSeconds` function:

{% codeblock lang:js mark:10-14 src/main.js %}
function afterTwoSeconds(callback) {
  return new Promise((resolve) => {
    setTimeout(() => {
      callback();
      resolve();
    }, 2000);
  });
}

if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
  module.exports = afterTwoSeconds;
} else {
  window.afterTwoSeconds = afterTwoSeconds;
}
{% endcodeblock %}

Note: We still export our code for Node.js environments, to make our code work in both worlds. That's why we keep [setTimeout](https://nodejs.org/dist/latest-v10.x/docs/api/timers.html#timers_settimeout_callback_delay_args) because it is available in Node.js and browser environments. If we would write `window.setTimeout` it would only work in browsers but fail in Node.js. 

### Update test

Our tests will run in the browser so we cannot import code with a `require` statement (CommonJS syntax) anymore and need to use the `window` namespace:

{% codeblock lang:js mark:4 src/main.test.js %}
describe('afterTwoSeconds', () => {
  it('resolves after 2 seconds', async () => {
    const myCallbackSpy = jasmine.createSpy('myCallbackSpy');
    await window.afterTwoSeconds(myCallbackSpy);
    expect(myCallbackSpy).toHaveBeenCalled();
  });
});
{% endcodeblock %}

### Add Karma configuration

A Karma configuration can be interactively created by running `npx karma init`. In our case we reuse the file paths from our Jasmine configuration.

For a successful Karma test run it is important to declare the source code and test code within the `files` property.

Karma can be equipped with a custom [test reporter](https://npmjs.org/browse/keyword/karma-reporter) but for now we are good with the standard `progress` reporter:

{% codeblock lang:js karma.conf.js %}
const jasmineConfig = require('./jasmine.json');

module.exports = function (config) {
  config.set({
    autoWatch: false,
    basePath: jasmineConfig.spec_dir,
    browsers: ['Chrome'],
    colors: true,
    concurrency: Infinity,
    exclude: [],
    files: [
      'main.js',
      ...jasmineConfig.spec_files
    ],
    frameworks: ['jasmine'],
    logLevel: config.LOG_INFO,
    port: 9876,
    preprocessors: {},
    reporters: ['progress'],
    singleRun: true,
  });
};
{% endcodeblock %}

## Add Webpack

### Update dependencies

We need to add `webpack-karma` so that Karma can use `webpack` to preprocess files. This also requires us to include `webpack` in our list of dependencies as it is a peer dependency of `webpack-karma`:

{% codeblock lang:json mark:7-8 package.json %}
{
  "devDependencies": {
    "jasmine": "3.4.0",
    "karma": "4.1.0",
    "karma-chrome-launcher": "2.2.0",
    "karma-jasmine": "2.0.1",
    "karma-webpack": "3.0.5",
    "webpack": "4.30.0"
  },
  "main": "src/main.js",
  "name": "karma-webpack-babel-typescript-istanbul",
  "scripts": {
    "start": "node index.js",
    "test": "karma start"
  },
  "version": "0.0.0"
}
{% endcodeblock %}

**Common mistake**

> ERROR [preprocess]: Can not load "webpack", it is not registered!
> Perhaps you are missing some plugin?

This happens when you run `karma start` and you forgot to install `webpack`.

### Add Webpack configuration

Thanks to webpack's zero configuration mode and its default settings, we don't need to specify much. All we do is defining a "development" mode to get detailed messages in case of preprocessing errors:  

{% codeblock lang:js webpack.config.js %}
module.exports = {
  mode: 'development'
};
{% endcodeblock %}

Using a "development" mode will decrypt error messages like `TypeError: r is not a function`.

### Update Karma configuration

In the previous Karma setup, our test code was relying that our business logic is exposed to the `window` namespace (`window.afterTwoSeconds`). Having webpack in place we will now load our business logic through our test code. That's why we don't need to declare our business logic anymore within Karma's `files` pattern. It's sufficient if we just point Karma to our test code because the tests will import the main source code for us. We can also reuse our webpack configuration by requiring it. To activate webpack, we need to declare it as a preprocessor for our test code. We also need to add the webpack configuration to our Karma configuration:

{% codeblock lang:js mark:1-2,7,12-14,18-20,23 karma.conf.js %}
const testCode = 'src/**/*test.js';
const webpackConfig = require('./webpack.config.js');

module.exports = function (config) {
  config.set({
    autoWatch: false,
    basePath: '',
    browsers: ['Chrome'],
    colors: true,
    concurrency: Infinity,
    exclude: [],
    files: [
      {pattern: testCode, watched: false}
    ],
    frameworks: ['jasmine'],
    logLevel: config.LOG_INFO,
    port: 9876,
    preprocessors: {
      [testCode]: ['webpack']
    },
    reporters: ['progress'],
    singleRun: true,
    webpack: webpackConfig
  });
};
{% endcodeblock %}

### Update imports

Our test code will now be preprocessed by webpack which means that we can use Node.js features like `require` statements to import code. Webpack will make sure that the `require` statements get processed into something that can be understood by our Browser environment:

{% codeblock lang:js mark:1,6 karma.conf.js %}
const afterTwoSeconds = require('./main');

describe('afterTwoSeconds', () => {
  it('resolves after 2 seconds', async () => {
    const myCallbackSpy = jasmine.createSpy('myCallbackSpy');
    await afterTwoSeconds(myCallbackSpy);
    expect(myCallbackSpy).toHaveBeenCalled();
  });
});
{% endcodeblock %}

## Add Babel

[Babel 7 ships with TypeScript support](https://devblogs.microsoft.com/typescript/typescript-and-babel-7/) and can be used to preprocess code with TypeScript's compiler. You might not need Babel to compile your code with TypeScript but using Babel's ecosystem (with presets like [@babel/preset-env](https://babeljs.io/docs/en/babel-preset-env)) can bring enormous benefits if you want to ship code for various environments. That's why it is the preferred setup in this tutorial, so let's get started with a Babel setup:

### Update dependencies

```bash
yarn add @babel/core babel-loader
```

{% codeblock lang:json mark:3-4 package.json %}
{
  "devDependencies": {
    "@babel/core": "7.4.4",
    "babel-loader": "8.0.5",
    "jasmine": "3.4.0",
    "karma": "4.1.0",
    "karma-chrome-launcher": "2.2.0",
    "karma-jasmine": "2.0.1",
    "karma-webpack": "3.0.5",
    "webpack": "4.30.0"
  },
  "main": "src/main.js",
  "name": "karma-webpack-babel-typescript-istanbul",
  "scripts": {
    "start": "node index.js",
    "test": "karma start"
  },
  "version": "0.0.0"
}
{% endcodeblock %}

### Add Babel configuration

We will start with a very basic Babel configuration which does not define any plugin our sets of plugins (called presets). Without plugins Babel won't do much which is okay for now and will be changed once we add TypeScript to our Babel toolchain. 

{% codeblock lang:js babel.config.js %}
module.exports = {
  plugins: [],
  presets: [],
};
{% endcodeblock %}

### Update webpack configuration

With the `babel-loader` we are telling `webpack` to process files ending on `.js` or `.jsx` (`/\.jsx?$/`) through Babel:

{% codeblock lang:js mark:3-11 webpack.config.js %}
module.exports = {
  mode: 'development',
  module: {
    rules: [
      {
        exclude: /(node_modules)/,
        loader: 'babel-loader',
        test: /\.jsx?$/,
      },
    ],
  },
};
{% endcodeblock %}

## Add TypeScript

### Update dependencies

```bash
yarn add @babel/preset-typescript @types/jasmine @types/node typescript --dev
```

{% codeblock lang:json mark:4-6,13 package.json %}
{
  "devDependencies": {
    "@babel/core": "7.4.4",
    "@babel/preset-typescript": "7.3.3",
    "@types/jasmine": "3.3.12",
    "@types/node": "12.0.0",
    "babel-loader": "8.0.5",
    "jasmine": "3.4.0",
    "karma": "4.1.0",
    "karma-chrome-launcher": "2.2.0",
    "karma-jasmine": "2.0.1",
    "karma-webpack": "3.0.5",
    "typescript": "3.4.5",
    "webpack": "4.30.0"
  },
  "main": "src/main.js",
  "name": "karma-webpack-babel-typescript-istanbul",
  "scripts": {
    "start": "node index.js",
    "test": "karma start"
  },
  "version": "0.0.0"
}
{% endcodeblock %}

### Add TypeScript configuration

```bash
tsc --init
```

{% codeblock lang:json tsconfig.json %}
{
  "compilerOptions": {
    "esModuleInterop": true,
    "lib": ["es6"],
    "module": "commonjs",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "target": "es6"
  }
}
{% endcodeblock %}

### Update webpack configuration

{% codeblock lang:js mark:8,12-14 webpack.config.js %}
module.exports = {
  mode: 'development',
  module: {
    rules: [
      {
        exclude: /(node_modules)/,
        loader: 'babel-loader',
        test: /\.[tj]sx?$/,
      },
    ],
  },
  resolve: {
    extensions: ['.js', '.jsx', '.ts', '.tsx'],
  },
};
{% endcodeblock %}

### Update Babel configuration

{% codeblock lang:js mark:3 babel.config.js %}
module.exports = {
  plugins: [],
  presets: ['@babel/preset-typescript'],
};
{% endcodeblock %}

### Migrate test code

We need to rename `main.test.js` to `main.test.ts`. Thanks to the `allowJs` [TypeScript compiler option](https://www.typescriptlang.org/docs/handbook/compiler-options.html) we can still import our JavaScript business logic within our test code:

{% codeblock lang:ts src/main.test.ts %}
const afterTwoSeconds = require('./main');

describe('afterTwoSeconds', () => {
  it('resolves after 2 seconds', async () => {
    const myCallbackSpy = jasmine.createSpy('myCallbackSpy');
    await afterTwoSeconds(myCallbackSpy);
    expect(myCallbackSpy).toHaveBeenCalled();
  });
});
{% endcodeblock %}

### Update Karma configuration

Our Karma setup now needs to load our migrated test code:

{% codeblock lang:js mark:1 karma.conf.js %}
const testCode = 'src/**/*test.ts';
const webpackConfig = require('./webpack.config.js');

module.exports = function (config) {
  config.set({
    autoWatch: false,
    basePath: '',
    browsers: ['Chrome'],
    colors: true,
    concurrency: Infinity,
    exclude: [],
    files: [
      {pattern: testCode, watched: false}
    ],
    frameworks: ['jasmine'],
    logLevel: config.LOG_INFO,
    port: 9876,
    preprocessors: {
      [testCode]: ['webpack']
    },
    reporters: ['progress'],
    singleRun: true,
    webpack: webpackConfig
  });
};
{% endcodeblock %}

## Migrate source code

### Update export

{% codeblock lang:ts mark:1 src/main.ts %}
export function afterTwoSeconds(callback: Function) {
  return new Promise((resolve) => {
    setTimeout(() => {
      callback();
      resolve();
    }, 2000);
  });
}
{% endcodeblock %}

### Update import

{% codeblock lang:ts mark:1 src/main.test.ts %}
import {afterTwoSeconds} from './main';

describe('afterTwoSeconds', () => {
  it('resolves after 2 seconds', async () => {
    const myCallbackSpy = jasmine.createSpy('myCallbackSpy');
    await afterTwoSeconds(myCallbackSpy);
    expect(myCallbackSpy).toHaveBeenCalled();
  });
});
{% endcodeblock %}

### Adjust start script

{% codeblock lang:json mark:16,19 package.json %}
{
  "devDependencies": {
    "@babel/core": "7.4.4",
    "@babel/preset-typescript": "7.3.3",
    "@types/jasmine": "3.3.12",
    "@types/node": "12.0.0",
    "babel-loader": "8.0.5",
    "jasmine": "3.4.0",
    "karma": "4.1.0",
    "karma-chrome-launcher": "2.2.0",
    "karma-jasmine": "2.0.1",
    "karma-webpack": "3.0.5",
    "typescript": "3.4.5",
    "webpack": "4.30.0"
  },
  "main": "dist/main.js",
  "name": "karma-webpack-babel-typescript-istanbul",
  "scripts": {
    "start": "tsc && node dist/main.js",
    "test": "karma start"
  },
  "version": "0.0.0"
}
{% endcodeblock %}

## Add code coverage

Note: Every package prefixed with `karma-` will be automatically added to [Karma's plugin section](http://karma-runner.github.io/4.0/config/plugins.html), so no need to define it.

### Update dependencies

```bash
yarn add istanbul-instrumenter-loader karma-coverage-istanbul-reporter --dev
```

### Update Karma configuration 

```bash
yarn add istanbul-instrumenter-loader karma-coverage-istanbul-reporter --dev
```

{% codeblock lang:json mark:8,12 package.json %}
{
  "devDependencies": {
    "@babel/core": "7.4.4",
    "@babel/preset-typescript": "7.3.3",
    "@types/jasmine": "3.3.12",
    "@types/node": "12.0.0",
    "babel-loader": "8.0.5",
    "istanbul-instrumenter-loader": "3.0.1",
    "jasmine": "3.4.0",
    "karma": "4.1.0",
    "karma-chrome-launcher": "2.2.0",
    "karma-coverage-istanbul-reporter": "2.0.5",
    "karma-jasmine": "2.0.1",
    "karma-webpack": "3.0.5",
    "typescript": "3.4.5",
    "webpack": "4.30.0"
  },
  "main": "dist/main.js",
  "name": "karma-webpack-babel-typescript-istanbul",
  "scripts": {
    "start": "tsc && node dist/main.js",
    "test": "karma start"
  },
  "version": "0.0.0"
}
{% endcodeblock %}

### Update webpack configuration

{% codeblock lang:js mark:10-18 webpack.config.js %}
module.exports = {
  mode: 'development',
  module: {
    rules: [
      {
        exclude: /(node_modules)/,
        loader: 'babel-loader',
        test: /\.[tj]sx?$/,
      },
      {
        enforce: 'post',
        exclude: /node_modules|\.test\.[tj]s$/,
        test: /\.[tj]s$/,
        use: {
          loader: 'istanbul-instrumenter-loader',
          options: {esModules: true}
        },
      }
    ],
  },
  resolve: {
    extensions: ['.js', '.jsx', '.ts', '.tsx'],
  },
};
{% endcodeblock %}

### Update Karma configuration

{% codeblock lang:js mark:11-14,25 karma.conf.js %}
const testCode = 'src/**/*test.ts';
const webpackConfig = require('./webpack.config.js');

module.exports = function (config) {
  config.set({
    autoWatch: false,
    basePath: '',
    browsers: ['Chrome'],
    colors: true,
    concurrency: Infinity,
    coverageIstanbulReporter: {
      fixWebpackSourcePaths: true,
      reports: ['html']
    },
    exclude: [],
    files: [
      {pattern: testCode, watched: false}
    ],
    frameworks: ['jasmine'],
    logLevel: config.LOG_INFO,
    port: 9876,
    preprocessors: {
      [testCode]: ['webpack']
    },
    reporters: ['progress', 'coverage-istanbul'],
    singleRun: true,
    webpack: webpackConfig
  });
};
{% endcodeblock %}

## Bonus: TypeScript everything!

...